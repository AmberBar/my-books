## 2
* 线程安全： 当多线程访问某个类，类始终能够表现出正确的行为，那么就说这个类是线程安全的。
* 竞态条件： 错误的执行时序导致不正确的结果。
* 复合操作：非原子操作
* 重入： 一个线程试图获取一个已经由自己持有的锁，请求会成功，不会发生死锁。“重入”获取锁的操作的粒度是线程而不是调用。重入的实现方式是，为每一个锁关联计数器和所有者，如果当前锁被获取持有计数器 +1，并且JVM会记录锁的持有者

<br>
note about synchronized:<br>

* synchronized 是一种内置锁，意味着如果线程A需要获取线程B持有的锁时，线程A必须等待或者阻塞，知道线程B释放这个锁。如果线程B永远不释放锁，那么A也就会永远地等待下去。

* synchronized 时可重入锁
<br>

容易产生竞态条件的condition:

* 读取-检查-写入
```java
    if (!vector.contains(ele)) {
        vector.add(ele)
    }

```
虽然vector是线程安全的，但是读取-检查-写入不是原子性的。因此需要额外加锁

```java
    synchronized {
        if (!vector.contains(ele)) {
            vector.add(ele)
        }
    }
```
## 3
* 同步代码块可以解决，一个线程在访问共享变量时，另一个线程对共享变量进行修改。
* 可见性: 可以解决一个线程修改完共享变量时，其他线程能够及时看到变化
to do list:

* AtomicReference:
* TimerTask:

